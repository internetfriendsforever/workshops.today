<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>workshops.today</title>
    <style media="screen">
      * {
        box-sizing: border-box;
      }
      body, html {
        height: 100%;
        margin: 0;
        color: rgba(255, 255, 255, 0.5);
        /* color: darkgreen; */
      }
      header {
        text-align: center;
        padding-bottom: 1em;
      }
      h1 {
        letter-spacing: -0.03em;
        word-spacing: -0.08em;
        color: darkgoldenrod;
        line-height: 1;
        font-family: times, "times new roman", serif;
        /* margin: 0; */
      }
      p {
        margin: 0;
        font-family: "arial narrow", sans-serif;
      }
      .wrapper {
        position: absolute;
        z-index: 1;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-direction: column;
        height: 100%;
        width: 100%;
        padding: 1em;
      }
      .top {
        align-self: flex-start;
      }
      .bottom {
        align-self: flex-end;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div class="top">
        <p>internetfriendsforever</p>
      </div>

      <header>
        <h1>
          workshops today for your<br />
          better tomorrow
        </h1>
        <p>
          10–16 December 2018<br />
          Low Standards<br />
          Pløens gate, Oslo
        </p>
      </header>

      <div class="bottom">
        <p>cyberspace·industries</p>
      </div>
    </div>

    <script src="https://unpkg.com/gl-matrix@2.4.0/dist/gl-matrix.js"></script>
    <script src="kefir.min.js"></script>

    <script>
      const canvas = document.createElement('canvas')
      const context = canvas.getContext('2d')

      const load = Kefir.fromEvents(window, 'load')

      const time = Kefir.stream(emitter => (
        function tick (time = 0) {
          emitter.emit(time)
          window.requestAnimationFrame(tick)
        }
      )()).toProperty(() => 0)

      const vectors = Kefir.constant(
        Array(20).fill().map(() => (
          vec3.fromValues(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
          )
        ))
      )

      const shapes = Kefir.constant(Array(2).fill().map((v, i, arr) => {
        const model = mat4.rotateY(mat4.create, mat4.identity(mat4.create()), (i / arr.length) * Math.PI)

        return [
          vec3.transformMat4(vec3.create(), vec3.fromValues(-0.5, -0.5, 0), model),
          vec3.transformMat4(vec3.create(), vec3.fromValues(0.5, -0.5, 0), model),
          vec3.transformMat4(vec3.create(), vec3.fromValues(0.5, 0.5, 0), model),
          vec3.transformMat4(vec3.create(), vec3.fromValues(-0.5, 0.5, 0), model)
        ]
      }))

      const getSize = () => ({
        width: window.innerWidth,
        height: window.innerHeight
      })

      const size = Kefir.fromEvents(window, 'resize')
        .map(getSize)
        .toProperty(getSize)

      const state = Kefir.combine(
        [time, size, vectors, shapes],
        (time, size, vectors, shapes) => ({ time, size, vectors, shapes })
      )

      const render = Kefir.combine([load, state], (load, state) => state)

      load.observe(loaded => {
        document.body.style.margin = 0
        document.body.style.background = '#051112'
        document.body.appendChild(canvas)
        canvas.style.width = '100%'
        canvas.style.height = '100%'
      })

      size.observe(size => {
        canvas.width = window.innerWidth * window.devicePixelRatio
        canvas.height = window.innerHeight * window.devicePixelRatio
      })

      render.observe(({ time, size, vectors, shapes }) => {
        const phase = time / 20000
        const base = mat4.fromValues(0.1, Math.sin(phase / 2) * 0.1, 0, 0, 0, 0.1, 0, 0, Math.sin(phase / 5) * 0.1, 0, 0.1, 0, 0, 0, 0, 0)
        const view = mat4.lookAt(mat4.create(), vec3.fromValues(Math.sin(phase) * 1.5, Math.sin(phase / 5) * 1, Math.cos(phase) * 1.5), vec3.fromValues(0, 0, 0), vec3.fromValues(0, -1, 0))
        const perspective = mat4.perspective(mat4.create(), Math.PI / 2000, 1, 0.01, 1000)
        const baseView = mat4.multiply(mat4.create(), base, view)
        const camera = mat4.multiply(mat4.create(), perspective, baseView)
        const origin = vec3.transformMat4(vec3.create(), vec3.fromValues(0, 0, 0), camera)

        context.clearRect(0, 0, canvas.width, canvas.height)
        context.save()
        context.translate(canvas.width / 2, canvas.height / 2)
        context.lineWidth = window.devicePixelRatio

        color('#ECC943')

        for (let x = -2; x <= 2; x++) {
          for (let y = -2; y <= 2; y++) {
            for (let z = -2; z <= 2; z++) {
              dot(vec3.transformMat4(vec3.create(), vec3.fromValues(x / 4, y / 4, z / 4), camera))
            }
          }
        }

        vectors.forEach(vector => {
          const [x, y] = vec3.transformMat4(vec3.create(), vector, camera)

          color('#235154')
          arrow(origin, [x, y])

          color('#C55C1B')
          cross([x, y])
        })

        color('#666')
        shapes.forEach(vertices => {
          context.beginPath()

          vertices.forEach((vertex, i) => {
            const [x, y] = vec3.transformMat4(vec3.create(), vertex, camera)
            context[i === 0 ? 'moveTo' : 'lineTo'](x, y)
          })

          context.closePath()
          context.stroke()
        })

        color('red')
        arrow(origin, vec3.transformMat4(vec3.create(), [base[0], base[1], base[2]], camera))

        color('blue')
        arrow(origin, vec3.transformMat4(vec3.create(), [base[4], base[5], base[6]], camera))

        color('green')
        arrow(origin, vec3.transformMat4(vec3.create(), [base[8], base[9], base[10]], camera))

        context.restore()
      })

      // Helpers
      function color (c) {
        context.strokeStyle = c
        context.fillStyle = c
      }

      function arrow (from, to) {
        const size = window.devicePixelRatio * 8

        line(from, to)

        context.save()
        context.translate(...to)
        context.rotate(Math.atan2(to[1] - from[1], to[0] - from[0]))
        context.beginPath()
        context.moveTo(-size, -size / 2)
        context.lineTo(0, 0)
        context.lineTo(-size, size / 2)
        context.fill()
        context.restore()
      }

      function line (from, to) {
        const [x1, y1] = from
        const [x2, y2] = to
        context.save()
        context.beginPath()
        context.moveTo(x1, y1)
        context.lineTo(x2, y2)
        context.stroke()
        context.restore()
      }

      function dot ([x, y]) {
        const size = window.devicePixelRatio * 1
        context.beginPath()
        context.arc(x, y, size, 0, Math.PI * 2)
        context.fill()
      }

      function cross ([x, y]) {
        const size = window.devicePixelRatio * 3
        context.beginPath()
        context.moveTo(x - size, y)
        context.lineTo(x + size, y)
        context.moveTo(x, y - size)
        context.lineTo(x, y + size)
        context.stroke()
      }

      function getAngle (a, b) {
        return Math.atan2(a, b)
      }
    </script>
  </body>
</html>
